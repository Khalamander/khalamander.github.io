<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesmerizing 3D Tunnel</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <script type="module">
        import * as THREE from 'https://esm.run/three';
        import { OrbitControls } from 'https://esm.run/three/examples/jsm/controls/OrbitControls';

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('myCanvas'), antialias: true });
        renderer.setPixelRatio(2); // High pixel ratio for crisp visuals
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Optional: Set a dark background if the scene itself isn't fully opaque
        renderer.setClearColor(0x000000);

        // --- Camera and Controls ---
        camera.position.set(0, 0, 0); // Start at the beginning of the tunnel
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // smooth camera movement
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.maxDistance = 100; // Allow some distance, but keep focus on the tunnel
        controls.minDistance = 0.1;
        controls.autoRotate = true; // Auto-rotate for initial mesmerizing effect
        controls.autoRotateSpeed = 0.5;
        controls.target.set(0, 0, -50); // Look slightly into the tunnel

        // --- Lighting ---
        scene.add(new THREE.AmbientLight(0x404040, 2)); // Soft ambient light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight2.position.set(-1, -1, -1).normalize();
        scene.add(directionalLight2);

        // --- Tunnel Parameters ---
        const tunnelSegments = [];
        const numSegments = 5; // Number of repeating tunnel sections
        const segmentDepth = 60; // How long each segment is along the Z axis
        const tunnelWidth = 30; // Max spread of objects on X/Y
        const numObjectsPerSegment = 150; // Number of small "fractal" pieces per segment
        const tunnelSpeed = 20; // How fast we "fall" through the tunnel

        const objectGeometry = new THREE.DodecahedronGeometry(0.8, 0); // Smaller dodecahedrons

        // --- Create Tunnel Segments ---
        for (let i = 0; i < numSegments; i++) {
            const segmentGroup = new THREE.Group();
            // Position segments behind the camera, with a gap for smooth transition
            segmentGroup.position.z = -i * segmentDepth - segmentDepth; 
            segmentGroup.userData.meshes = []; // Store meshes for individual animation

            for (let j = 0; j < numObjectsPerSegment; j++) {
                const meshMaterial = new THREE.MeshStandardMaterial({
                    metalness: 0.5,
                    roughness: 0.3,
                    flatShading: true
                });
                const mesh = new THREE.Mesh(objectGeometry, meshMaterial); 
                
                // Random position within a wider 'tunnel' area
                mesh.position.x = (Math.random() - 0.5) * tunnelWidth * 2;
                mesh.position.y = (Math.random() - 0.5) * tunnelWidth * 2;
                mesh.position.z = (Math.random() - 0.5) * segmentDepth; // Random Z within segment's depth

                // Initial random rotation
                mesh.rotation.x = Math.random() * Math.PI * 2;
                mesh.rotation.y = Math.random() * Math.PI * 2;
                mesh.rotation.z = Math.random() * Math.PI * 2;

                // Store initial properties for dynamic scaling
                mesh.userData.initialScale = 0.5 + Math.random() * 1.5; 
                mesh.userData.initialRotationX = Math.random() * Math.PI * 2;
                mesh.userData.initialRotationY = Math.random() * Math.PI * 2;
                mesh.userData.initialRotationZ = Math.random() * Math.PI * 2;

                segmentGroup.add(mesh);
                segmentGroup.userData.meshes.push(mesh);
            }
            scene.add(segmentGroup);
            tunnelSegments.push(segmentGroup);
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            // Move segments and reset if they go too far back
            for (let i = 0; i < numSegments; i++) {
                const segment = tunnelSegments[i];
                segment.position.z += tunnelSpeed * delta; // Move towards camera

                // If segment has passed camera (its center is ahead of camera), reset it to the far end
                if (segment.position.z > camera.position.z + segmentDepth / 2) {
                    segment.position.z -= numSegments * segmentDepth; // Move to the end of the tunnel chain

                    // Randomize positions and initial properties of meshes within the reset segment
                    // This avoids visual repetition and keeps the "fractal" feel fresh
                    segment.userData.meshes.forEach(mesh => {
                        mesh.position.x = (Math.random() - 0.5) * tunnelWidth * 2;
                        mesh.position.y = (Math.random() - 0.5) * tunnelWidth * 2;
                        mesh.position.z = (Math.random() - 0.5) * segmentDepth; // Reset local Z position

                        mesh.userData.initialScale = 0.5 + Math.random() * 1.5;
                        mesh.userData.initialRotationX = Math.random() * Math.PI * 2;
                        mesh.userData.initialRotationY = Math.random() * Math.PI * 2;
                        mesh.userData.initialRotationZ = Math.random() * Math.PI * 2;
                    });
                }

                // Apply "fractal" like transformations to individual meshes
                segment.userData.meshes.forEach((mesh, index) => {
                    // Calculate global Z position for effects, relative to camera (0,0,0)
                    const globalZ = segment.position.z + mesh.position.z; 

                    // Scale animation: Pulsating effect based on depth, time, and position
                    // This creates a sense of evolving, complex structures
                    const scaleFactor = 1 + Math.sin(elapsedTime * 0.5 + globalZ * 0.1 + mesh.position.x * 0.05 + mesh.position.y * 0.05) * 0.8;
                    mesh.scale.setScalar(mesh.userData.initialScale * scaleFactor);

                    // Rotation animation: Continuous rotation with an undulating speed
                    mesh.rotation.x = mesh.userData.initialRotationX + elapsedTime * 0.1 * (1 + Math.sin(elapsedTime * 0.3 + index * 0.01));
                    mesh.rotation.y = mesh.userData.initialRotationY + elapsedTime * 0.2 * (1 + Math.cos(elapsedTime * 0.4 + index * 0.01));
                    mesh.rotation.z = mesh.userData.initialRotationZ + elapsedTime * 0.15 * (1 + Math.sin(elapsedTime * 0.2 + index * 0.01));

                    // Color animation: HSL values shifting based on depth and time
                    // Creates a mesmerizing, evolving color palette
                    const hue = (elapsedTime * 0.05 + globalZ * 0.005) % 1; // Hue shifts over time and depth
                    const saturation = 0.6 + Math.sin(elapsedTime * 0.8 + index * 0.02) * 0.3; // Saturation pulsates
                    const lightness = 0.5 + Math.cos(elapsedTime * 0.7 + index * 0.03) * 0.2; // Lightness pulsates
                    mesh.material.color.setHSL(hue, saturation, lightness);
                });
            }

            controls.update(); // Update orbit controls
            renderer.render(scene, camera);
        }

        animate();

        // --- Window Resizing ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>