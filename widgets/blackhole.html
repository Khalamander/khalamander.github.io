<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.run/three",
                "three/addons/": "https://esm.run/three/addons/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        let scene, camera, renderer, controls, composer;
        let accretionDisk, blackHole;
        let lensingPass;
        const clock = new THREE.Clock();

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 8);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(2);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 50;
            
            // Starfield
            createStarfield();

            // Black Hole
            const blackHoleGeometry = new THREE.SphereGeometry(1, 64, 64);
            const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            scene.add(blackHole);

            // Accretion Disk
            createAccretionDisk();

            // Post-processing for Gravitational Lensing
            setupPostProcessing();

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        function createStarfield() {
            const starsVertices = [];
            for (let i = 0; i < 20000; i++) {
                const x = THREE.MathUtils.randFloatSpread(200);
                const y = THREE.MathUtils.randFloatSpread(200);
                const z = THREE.MathUtils.randFloatSpread(200);
                starsVertices.push(x, y, z);
            }
            const starsGeometry = new THREE.BufferGeometry();
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8
            });
            const starfield = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starfield);
        }

        function createAccretionDisk() {
            const diskGeometry = new THREE.RingGeometry(1.1, 4, 128);
            
            const diskVertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            
            const diskFragmentShader = `
                varying vec2 vUv;
                uniform float uTime;

                // 2D simplex noise function
                vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
                float snoise(vec2 v) {
                    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                    vec2 i  = floor(v + dot(v, C.yy));
                    vec2 x0 = v - i + dot(i, C.xx);
                    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                    vec4 x12 = x0.xyxy + C.xxzz;
                    x12.xy -= i1;
                    i = mod(i, 289.0);
                    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
                    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                    m = m*m; m = m*m;
                    vec3 x = 2.0 * fract(p * C.www) - 1.0;
                    vec3 h = abs(x) - 0.5;
                    vec3 ox = floor(x + 0.5);
                    vec3 a0 = x - ox;
                    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                    vec3 g;
                    g.x  = a0.x  * x0.x  + h.x  * x0.y;
                    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                    return 130.0 * dot(m, g);
                }

                void main() {
                    vec2 centeredUv = vUv - 0.5;
                    float radius = length(centeredUv) * 2.0; // Remap radius to 0-1 range
                    float angle = atan(centeredUv.y, centeredUv.x);

                    // Differential rotation (Keplerian-like)
                    float speed = 0.2 / (radius * radius + 0.1);
                    float distortedAngle = angle + uTime * speed;
                    
                    vec2 distortedUv = vec2(cos(distortedAngle), sin(distortedAngle)) * radius * 2.0;

                    float noise = snoise(distortedUv * 4.0) * 0.5 + 0.5;
                    
                    // Add some radial streaks
                    float streaks = sin((radius - uTime * 0.05) * 40.0) * 0.2 + 0.8;
                    noise *= streaks;

                    // Color based on radius
                    vec3 color1 = vec3(1.0, 1.0, 0.8); // White-yellow
                    vec3 color2 = vec3(1.0, 0.5, 0.0); // Orange
                    vec3 color3 = vec3(0.8, 0.0, 0.0); // Red
                    
                    vec3 color = mix(color1, color2, smoothstep(0.0, 0.6, radius));
                    color = mix(color, color3, smoothstep(0.6, 1.0, radius));

                    float intensity = noise * (1.0 - radius) * 2.0; // Brighter towards center
                    
                    // Smooth fade at inner and outer edges
                    float innerEdge = smoothstep(0.0, 0.1, radius);
                    float outerEdge = 1.0 - smoothstep(0.9, 1.0, radius);
                    float alpha = innerEdge * outerEdge;
                    
                    gl_FragColor = vec4(color * intensity, alpha);
                }
            `;

            const diskMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0.0 }
                },
                vertexShader: diskVertexShader,
                fragmentShader: diskFragmentShader,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
            accretionDisk.rotation.x = -Math.PI / 2;
            scene.add(accretionDisk);
        }

        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const LensingShader = {
                uniforms: {
                    "tDiffuse": { value: null },
                    "uBlackHolePos": { value: new THREE.Vector2(0.5, 0.5) },
                    "uMass": { value: 0.015 },
                    "uAspectRatio": { value: window.innerWidth / window.innerHeight }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 uBlackHolePos;
                    uniform float uMass;
                    uniform float uAspectRatio;
                    varying vec2 vUv;

                    void main() {
                        vec2 centeredUv = vUv - uBlackHolePos;
                        centeredUv.x *= uAspectRatio;

                        float dist = length(centeredUv);
                        
                        // Prevent extreme distortion at center
                        if (dist == 0.0) {
                            gl_FragColor = texture2D(tDiffuse, vUv);
                            return;
                        }

                        // Lensing formula: displacement proportional to mass/distance
                        float displacement = uMass / dist;
                        
                        // Bend the light towards the center
                        vec2 distortedUv = vUv - normalize(centeredUv) * displacement;
                        
                        gl_FragColor = texture2D(tDiffuse, distortedUv);
                    }
                `
            };
            lensingPass = new ShaderPass(LensingShader);
            composer.addPass(lensingPass);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.uAspectRatio.value = window.innerWidth / window.innerHeight;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();

            controls.update();
            
            // Update accretion disk animation
            accretionDisk.material.uniforms.uTime.value = elapsed;

            // Update lensing effect position
            const screenPos = new THREE.Vector3();
            blackHole.getWorldPosition(screenPos);
            screenPos.project(camera); // Project to normalized device coordinates (-1 to +1)
            lensingPass.uniforms.uBlackHolePos.value.x = (screenPos.x + 1) / 2;
            lensingPass.uniforms.uBlackHolePos.value.y = (screenPos.y + 1) / 2;

            composer.render(delta);
        }

        init();
        animate();
    </script>
</body>
</html>